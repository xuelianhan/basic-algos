package org.ict.algorithm.leetcode.string;

/**
 * You are given a string s consisting only of letters 'a' and 'b'.
 * In a single step you can remove one palindromic subsequence from s.
 *
 * Return the minimum number of steps to make the given string empty.
 *
 * A string is a subsequence of a given string if it is generated by
 * deleting some characters of a given string
 * without changing its order.
 * Note that a subsequence does not necessarily need to be contiguous.
 *
 * A string is called palindrome if is one that reads the same backward as well as forward.
 *
 *
 *
 * Example 1:
 * Input: s = "ababa"
 * Output: 1
 * Explanation: s is already a palindrome, so its entirety can be removed in a single step.
 *
 * Example 2:
 * Input: s = "abb"
 * Output: 2
 * Explanation: "abb" -> "bb" -> "".
 * Remove palindromic subsequence "a" then "bb".
 *
 * Example 3:
 * Input: s = "baabb"
 * Output: 2
 * Explanation: "baabb" -> "b" -> "".
 * Remove palindromic subsequence "baab" then "b".
 *
 *
 * Constraints:
 *
 * 1 <= s.length <= 1000
 * s[i] is either 'a' or 'b'.
 * @author sniper
 * @date 10 Aug, 2022
 * LC1332
 */
public class RemovePalindromicSubsequences {


    /**
     * Solution provided by lee215
     *
     * Good to Know
     * You need to know the difference between subarray and subsequence.
     * Subarray need to be consecutiveã€‚
     * Subsequence don't have to be consecutive.
     *
     *
     * Intuition
     * If it's empty sting, return 0;
     * If it's palindrome, return 1;
     * Otherwise, we need at least 2 operation.
     *
     *
     * Explanation
     * We can delete all characters 'a' in the 1st operation,
     * and then all characters 'b' in the 2nd operation.
     * So return 2 in this case
     *
     *
     * Complexity
     * Time O(N)
     * Space O(N), also O(1) space checking palindrome is suuggested.
     * @param s
     * @return
     */
    public int removePalindromeSubV2(String s) {
        if (null == s || "".equals(s)) {
            return 0;
        }
        String reversed = new StringBuilder(s).reverse().toString();
        return (s.equals(reversed) ? 1 : 2);
    }


    public int removePalindromeSub(String s) {
        if (isPalindrome(s, 0, s.length() - 1)) {
            return 1;
        }
        return 2;
    }

    public boolean isPalindrome(String s, int lo, int hi) {
        while (lo < hi) {
            if (s.charAt(lo) != s.charAt(hi)) {
                return false;
            } else {
                lo++;
                hi--;
            }
        }
        return true;
    }
}
